# DOCUMENTACIÓN
Hecho por: Federico Martín Cortázar (311721)

| PROBLEMA | RESULTADO |
|----------|-----------|
| 1        | Completo  |
| 2        | Completo  |
| 3        | Completo  |
| 4        | Completo  |
| 5        | Completo  |
| 6        | Completo  |
| 7        | Completo  |
| 8        | Completo  |
| 9        | Completo  |
| 10       | Completo  |


## EJERCICIO 1
Para hallar la solución del ejercicio 1 cree un árbol AVL donde los elementos se insertan según su ID, a su vez dicho árbol lleva la cuenta de cuantos libros están habilitados y cuantos no. El orden de las operaciones de inserción, búsqueda, y actualización de estado se realicen en tiempo O(log N) siendo N la cantidad de nodos ya que a medida que se llega a un nuevo nodo preguntas si tu ID es mayor, menor o igual, si es igual haces la operación que tengas que hacer, en otro caso vas a la derecha o a la izquierda dependiendo de si tu ID es mayor o menor y el orden de la operación COUNT es $O(1)pc$  ya que al tener la cantidad de libros habilitados y cuantos no se accede siempre en $O(1)pc$ , y para tener el total solo hay que sumar estos dos números.
Para hacer este ejercicio tome la implementación de AVL dada en clase.

## EJERCICIO 2
Para hallar la solución del ejercicio 2 cree una tabla de hash con hashing cerrado y con una resolución de colisiones mediante doble hash, Además tiene la cantidad de libros habilitados y la cantidad de libros deshabilitados y cuál es el tamaño del array. El orden para las operaciones de inserción, búsqueda y actualización de estado es $O(1)cp$ ya que es este el orden que tiene la tabla de hash para estas funciones y el orden de la operación COUNT es de $O(1)pc$ ya que al tener la cantidad de libros habilitados y cuantos no se accede siempre en $O(1)pc$ , y para tener el total solo hay que sumar estos dos números.
Para hacer este ejercicio tome lo que dimos en clase de hash abierto y lo pase a hash cerrado.

## EJERCICIO 3
Para hallar la solución de este ejercicio utilice un min heap ya que te pide que ordenes los objetos de menor a mayor dependiendo de ciertos criterios, dicho min heap guarda un id y un precio en cada posición del array. El orden de esta solución es de $O(N logN)pc$ siendo $N$ la cantidad de datos ya que insertamos $N$ datos y la función de insertar en un heap tiene $O(logN)pc$.
Para hacer este ejercicio tome lo que dimos en clase sobre heap y lo modifique a lo que se pide.

## EJERCICIO 4
Para hallar la solución de este ejercicio utilice un min heap con una tabla de hash con hashing abierto ya que te pide que ordenes los objetos de menor a mayor dependiendo de ciertos criterios y se puede cambiar algunos valores de un dato ya ingresado, por lo que necesito la tabla para guardar la posición de los datos en el array para acceder en $O(1)cp$, dicho min heap guarda un id, una prioridad, si es para llevar y que tiene el pedido en cada posición del array. El orden de esta solución es de $O(N logN)cp$ siendo $N$ la cantidad de elementos  ya que insertamos $N$ datos y la función de insertar en un heap tiene $O(logN)pc$ y el orden es de $O(N^2)pc$ si la tabla de hash tiene una función de hash mala por lo que tiene un $O(N)$ y se ingresan $N$ veces $C$ por lo que hay que aplicar $N$ veces la tabla de hash para encontrar la posición en el array. 
Para implementar todo esto utilice lo dado en clase sobre min heap y sobre la tabla de hash y lo adapte a lo que te pide el ejercicio

## EJERCICIO 5
Para hallar la solución de este ejercicio utilice dos algoritmos, el primero es el algoritmo del orden topológico ya que me dice cual misión esta lista para ser ejecutada, por lo que necesite de una cola y de un grafo dirigido (implementado con lista de adyacencia) y el segundo algoritmo que utilice es Dijkstra ya que me dice que ciudad esta más cerca de donde estoy ubicado, por lo que necesite de un min heap y, en este caso, un grafo no dirigido (implementado con lista de adyacencia). El orden temporal es de $O((M + Dep) + M * ((C + E) * log C))$, donde $Dep$ es la cantidad de dependencias entre misiones , $E$ es la cantidad de conexiones entre ciudades, $M$ es la cantidad de misiones a realizar y $C$ es la cantidad de misiones, este orden se debe a que se realizar el algoritmo de orden topológico tiene un $O(M + Dep)$ donde $M$ es la cantidad de vértices y $Dep$ es la cantidad de aristas del grafo dirigido y a que realizo $M$ veces el algoritmo de Dijkstra (implementado con min heap) que tiene un $O((C + E) * log C)$ donde el grafo no dirigido tiene $C$ vértices y $E$ aristas.
Para implementar todo esto utilice lo que dimos en clase sobre grafos, orden tipológico y Dijkstra y lo adapte a lo que se pide

## EJERCICIO 6
Para hallar la solución de este ejercicio utilice el algoritmo de Dijkstra ya que me dice el menor costo de ir de un vértice a otro, por lo que necesite de un min heap y, en este caso, de un grafo no dirigido (implementado con una lista de adyacencia) y para cada camino o arista que utilice duplique su valor. El orden de esta solución es igual al orden de Dijkstra implementado con un min heap que es de $O((C + Con) * log C)$ siendo $C$ la cantidad de ciudades y de vértices y $Con$ la cantidad de conexiones entre ciudades y aristas del grafo no dirigido, tiene este orden ya que no aplica Dijkstra de forma anidada sino que de forma contigua.
Para implementar todo esto utilice lo que dimos en clase sobre Dijkstra y grafos y lo adapte a lo que me piden.

## EJERCICIO 7
Para resolver este problema utilice un enfoque basado en la búsqueda binaria sobre el rango de tiempos posibles y una función que valida si la asignación es válida dado un tiempo máximo permitido por alumno. Para hallar el tiempo adecuado primero halle el máximo tiempo posible y el mínimo y luego probaba con la mitad de estos dos, si se puede realizar dicho tiempo probaba con un valor intermedio entre este valor y el mínimo, si no era posible probaba un valor intermedio entre este valor y el máximo, volvía hacer esto repetidamente hasta encontrar un valor el cual no pueda seguir dividendo a la mitad. El orden es de $O(log(T)N˙)$ siendo $T$ la suma de las duraciones de las canciones y $N˙$ la cantidad de cancones en la lista ya que a medida cada vez se el rango de divide a la mitad por lo que tiene $O(logT)$ y la función de validación recorre todas las canciones por lo que tiene $O(N)$, y al combinar estas dos funciones tenemos el orden final.
Para implementar todo esto aplique lo que dimos en clase sobre búsqueda binaria y lo adapte a lo que se pedía.

## EJERCICIO 8
Para resolver este ejercicio utilicé el algoritmo de Divide & Conquer, que consiste en dividir el conjunto de puntos en dos mitades. Primero ordené los puntos según su coordenada en el eje X utilizando Merge Sort para facilitar la división. Una vez dividido el conjunto, calculé de forma recursiva la distancia mínima entre los puntos de cada mitad. Luego comparé estas distancias con la mínima distancia de los puntos cercanos a la línea divisoria que separa ambas mitades. Los puntos centrales son aquellos que están a una distancia menor o igual a la mínima distancia calculada entre las dos mitades. Para optimizar el cálculo de las distancias en esta región central, también ordené estos puntos por su coordenada en el eje Y utilizando nuevamente Merge Sort, lo que me permitió comparar de manera eficiente los puntos desde abajo hacia arriba según este orden. Además, para hallar la distancia mínima central, comparé los puntos que se encuentran a un lado de la línea divisoria con los que están del otro lado para asegurar que no se omitieran posibles pares con una distancia mínima. En los casos base, cuando había solo dos o tres puntos, calculé la distancia mínima mediante un enfoque de fuerza bruta, evaluando directamente las distancias entre ellos. Finalmente, al comparar las distancias mínimas obtenidas en las dos mitades y en la región central, determiné la distancia mínima global entre dos puntos del conjunto y cuáles son esos puntos.
Para implementar todo esto aplique lo que dimos en clase sobre Divide & Conquer y Merge Sort y lo adapte a lo que se pedia.

## EJERCICIO 9
Para resolver este problema utilicé programación dinámica, específicamente la técnica de tabulación, implementando una versión de la mochila 0-1 con tres restricciones: el presupuesto, la cantidad de futbolistas extranjeros y la cantidad máxima de jugadores en la alineación inicial (11 jugadores). Se crea una matriz tab de cuatro dimensiones, donde cada dimensión corresponde a un parámetro específico. La primera dimensión, jugAct, corresponde a la iteración sobre los jugadores, y no representa una restricción, sino que sirve como índice para procesar cada jugador de manera secuencial. Las tres dimensiones clave son: capSalarioAct, que representa el presupuesto disponible en un momento dado; capExtraJugAct, que limita la cantidad de jugadores extranjeros; y capOnceJugAct, que establece la cantidad de jugadores necesarios en el once inicial.
El proceso comienza con la inicialización de la matriz, asignando un valor de cero a cada entrada de forma predeterminada, lo que indica que no se ha considerado ninguna solución en ese punto. Luego, se itera sobre cada jugador, evaluando dos opciones: incluirlo en el equipo o no. Si el valor de incluir al jugador, sumando su valoración y el valor obtenido de la matriz considerando las restricciones actualizadas (como el salario, el cupo como jugador extranjero, y la posición en el once inicial), es mayor que el valor de no incluirlo, entonces se actualiza la matriz con ese valor. Si no es así, se mantiene el valor de no incluir al jugador. Este proceso se repite hasta recorrer toda la matriz. Su orden temporal es de $O(J * P * E)$ siendo $J$ la cantidad de jugadores en el plantel, $ P$ el presupuesto del club y $E$ el cupo máximo de jugadores extranjeros, esto se debe a que el algoritmo de la mochila en tabulación utiliza 4 for anidados los cuales tienen como valor máximo $J$, $P$ , $E$ y $11$, pero como el ultimo es una constante se saca por lo que el orden temporal queda así $O(J * P * E)$.
Para implementar todo esto aplique lo que dimos en clase sobre la mochila implementada con programacion dinamica y tabulacion y lo adapte a lo que se pide.

## EJERCICIO 10
Para resolver este problema, utilicé el algoritmo de optimizacion de backtracking, cuyo objetivo es explorar sistemáticamente todas las posibles configuraciones del jardín para encontrar aquella que permita colocar la mayor cantidad de flores, respetando las restricciones dadas.
El programa está estructurado con varias funciones auxiliares. Por ejemplo, la función $esSolucion$ verifica si se ha alcanzado la última columna del jardín, lo que indica que se ha completado una posible configuración. Por otro lado, $esMejorSolucion$ compara la cantidad de flores colocadas en la solución actual con la mejor solución encontrada hasta el momento y, si es mejor, actualiza esta última. Para manipular el estado del jardín, se utilizan las funciones $aplicarMovimiento$ y $deshacerMovimiento$, que permiten agregar o retirar una flor de una celda específica, actualizando simultáneamente el conteo total de flores colocadas. Además, la función puedoAplicarMovimiento\text{puedoAplicarMovimiento}puedoAplicarMovimiento garantiza que colocar una flor en una celda cumpla con las restricciones de adyacencia y fila.
El algoritmo aplica recursividad tras cada movimiento válido, avanzando a la siguiente posición del jardín para explorar todas las posibles combinaciones de flores. Este proceso asegura que se evalúen todas las configuraciones posibles, al mismo tiempo que se descartan aquellas que violan las restricciones.
Para implementar todo esto aplique lo que dimos en clase sobre el algoritmo de optimizacion backtracking y lo adapte a lo que se pide. 